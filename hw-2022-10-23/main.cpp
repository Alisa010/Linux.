/*Написать программу, реализующую следующее поведение shell:
p1; p2; ... pn;
Такая конструкция означает последовательный запуск программ: перед запуском очередной программы нужно дождаться завершения предыдущей.
То есть сначала создается сыновий процесс, который заменяет свое тело программой p1, отец ждет его завершения. Затем создается процесс для p2, и так далее. При поиске программ должна использоваться переменная окружения PATH (для этого нужно использовать правильный exec).
Имена программ (p1, p2, ..., pn) передаются Вашей программе в аргументах командной строки.
Пример (a.out - исполняемый файл вашей программы):
./a.out pwd ls date
В результате будет создано 3 сына (не сразу, последовательно), выведется текущая рабочая директория, после этого содержимое текущей директории, и в конце текущая дата.
 */
#include <iostream> 
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char** argv){
   
  for(int i = 1; i < argc; ++i){
    char* arr[]{argv[i], nullptr};
    pid_t pid = fork();
    
    if(pid < 0){
        std::cout << "ERROR";
    }


    else if(pid == 0){
      std::cout << "child = " << getpid() << std::endl;
      execvp(argv[i], arr);

  }

    else if(pid > 0){
      int status;
      int waitpid = wait(&status);
      
    }

  }
}

